验证 keep-alive（同一连接连续两次请求）
✅用 nc 直接发两个请求，观察是否都返回且不断开：
printf 'GET / HTTP/1.1\r\nHost: example.local\r\nConnection: keep-alive\r\n\r\nGET / HTTP/1.1\r\nHost: example.local\r\nConnection: close\r\n\r\n' \
| nc -v $HOST $PORT
期望：能看到两段响应，第二段后连接关闭。

************
failed

->第一份请求处理完以后，连接状态机没有正确回到“read request line / parse headers”的状态，或没有正确消费 socket 缓冲里剩余的数据。
“每次 epollin 只读一次”，读到了第一份请求，剩余字节没处理
Il faut:支持 pipelining
->第二个请求在同一包里到达时，被缓存住
等第一个响应完全写完后，再开始读剩余 buffer
但目前显然没有正确缓存/回放这个剩余 buffer，所以仍然走向 408
*************
=============================================
curl 指令： 
curl -v --http1.1 \
  "$BASE/" \
  "$BASE/"
第二个请求会出现re-using existing connection，说明同一个tcp的请求没有关闭，连接存在并且复用

显式connection： close 
curl -v --http1.1 \
  "$BASE/" \
  -H "Connection: close" \
  "$BASE/"
现在的结果： 
	2个指令全部close，然后对于第二个指令创建了一个新的connection，2个线路都被关闭 
==============================================


✅ 4）Request line多余token（接受）
printf 'GET / HTTP/1.1 EXTRA\r\nHost: example.local\r\n\r\n' | nc -v $HOST $PORT
request line extra token accepted
	•	GET / HTTP/1.1 EXTRA
验证点：
	•	parser仍然接受
解析仍成功
行为应当与正常 GET / HTTP/1.1 等价（通常 200 或既定输出）
不能因为 extra token 就 400
***************
ATTENT
现在的策略是：对 keep-alive 连接，如果下一请求迟迟不到，就发 408
很多实现不会在 keep-alive 空闲时主动发 408，而是 simply close socket 或者不回应直到 client 发新请求
行为更接近主流实现:
如果是 idle keep-alive 超时：直接 close(fd)，不发送 408
408 更适合这种场景：你已经收到请求开头，但请求一直没完整到达（incomplete request timeout），而不是“连接空闲等待下一个请求”
***************
=====================
curl 指令： 
curl -v --http1.1 \
  -H "Host: localhost:$PORT" \
  "$BASE/upload/hello.txt"
期待结果： 
	200 或者404,看文件是否存在
现在结果： 
	文档在www/upload/hello.txt， 返回值200/404 
	tcp底层连接没问题
	reponse connection keepalive 
=====================

✅2）Host 带端口（合法）
printf 'GET upload/hello.txt HTTP/1.1\r\nHost: localhost:%s\r\n\r\n' "$PORT" \
| nc -v $HOST $PORT | sed -n '1,30p'
curl -v "http://$HOST:$PORT/upload/hello.txt" -H "Host: localhost:$PORT" --http1.1
Host with port accepted
	•	Host: localhost:8080
验证点：
	•	parser 接受
期望
不是 400（应进入正常路由逻辑，可能 200/404，看 hello.txt 是否存在）
不应因为 Host 含端口而判 bad_request
***************
failed
keep-alive 空闲超时：通常应当直接关闭连接，不再发送新的 HTTP 响应。
超时逻辑”在 keep-alive 空闲期触发后，没有选择“安静地 close”，而是又构造了一个 408 发给客户端，然后 close。
***************
===================
update:
现在结果： 
	文件路径检查都没问题，回复404/200 
	tcp 底层连接保持
	reponse connection keepalive 
====================

✅4）Host 为空值
printf 'GET /hello.txt HTTP/1.1\r\nHost:\r\n\r\n' | nc -v $HOST $PORT | sed -n '1,30p'
期望：400
***************
failed
404 + 408 != 400
timeout + keep_alive
***************
==========================
update:
	return 400
==========================

✅5）Host 只有空白
printf 'GET /hello.txt HTTP/1.1\r\nHost:   \r\n\r\n' | nc -v $HOST $PORT | sed -n '1,30p'
***************
failed
404 + 408 != 400
timeout + keep_alive
***************
=========================
update:
	return 400 
=========================

3.3 URI
✅1）absolute-form + Host 一致（含端口）
printf 'GET http://example.com:%s/path HTTP/1.1\r\nHost: example.com:%s\r\n\r\n' "$PORT" "$PORT" \
| nc -v $HOST $PORT | sed -n '1,40p'
absolute-form OK
	•	GET http://example.com:8080/path
	•	Host: example.com:8080
验证点：
	•	path == /path
	•	parser接受
不应返回 400
行为应当等价于请求 /path（例如返回 200/404，取决于服务器是否存在 /path 对应资源）
***************
failed
404 + 408 != 400
timeout + keep_alive
***************
===========================
update: 
	curl 指令：
	curl -v --http1.1 \
  --resolve example.com:$PORT:127.0.0.1 \
  "http://example.com:$PORT/path"

期待值： 
	200/404, 看文件存在
现在结果： 
	404
	用	curl -v --http1.1 \
  --resolve example.com:$PORT:127.0.0.1 \
  "http://example.com:$PORT/upload/hello.txt" 输入检查后结果是200,文件存在

==========================

URL 编码的 ..
%2e%2e 等价于 ..
❓printf 'GET /a/%2e%2e/b HTTP/1.1\r\nHost: example.local\r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,40p'
拍摄：至少要保证“不崩”，并且行为一致（要么明确 400，要么按字面当普通路径）
***************
failed
404+408
“发现回退就 403”，那 %2e%2e 这种等价写法也必须 403。正确处理顺序应当是
先对 path 做 percent-decoding（至少把 %2e %2f 等解出来）
再做 path normalization（. .. 消解）
再检查是否越出 root
最后才去拼接到文件系统路径并决定 200/404/403
***************
========================================
update：
curl 指令： 
curl -v --http1.1 \
  "$BASE/a/%2e%2e/b"
现在结果： 
	返回404
	tcp 底层连接保持 
	reponse： connection keepalive 
========================================


✅6）Query string 与路径分离
解析应满足：path == upload/hello.txt，query 不应参与文件路径映射。
curl -isS --http1.1 "$BASE/upload/hello.txt?x=1&y=2" -H "Host: localhost" | sed -n '1,20p'
期望： 200，且读取的是 www/hello.txt。
***************
failed
404+408
***************
=============================================
update： 
curl指令： 
curl -v --http1.1 \
  "$BASE/upload/hello.txt?x=1&y=2"
现在结果： 
	目前返回值 200,成功找到www/upload/hello.txt 文档 
	connection keepalive 保持连接
=============================================

3.4 Connection/Keep-Alive行为
❓1）Connection: close, keep-alive
printf 'GET /upload/hello.txt HTTP/1.1\r\nHost: example.local\r\nConnection: close, keep-alive\r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,40p'
Connection close, keep-alive NOT treated as close
	•	token list
验证点：
	•	parser 只在完全等于 “close” 时才关闭
	•	这里 keep_alive == true
响应不应带 Connection: close（或至少你们内部 keep_alive 应为 true）
更关键是验证“连接复用”，用同一条 TCP 连接再发第二个请求，看是否还能收到响应
***************
failed
404+408
***************
==============================================
update：
curl指令： 
curl -v --http1.1 \
  -H "Connection: close, keep-alive" \
  "$BASE/upload/hello.txt" \
  "$BASE/hello.txt"
现在结果： 
	文件路径检查，2个都没问题，返回404/200 
	tcp connection：第二个有复用第一个线路，并且都没有关闭
	reponse： 2个都是keepalive状态
==============================================


printf 'GET /upload/hello.txt HTTP/1.1\r\nHost: example.local\r\nConnection: close, keep-alive\r\n\r\nGET /hello.txt HTTP/1.1\r\nHost: example.local\r\nConnection: close\r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,120p'
第一段响应后连接仍然活着，第二个请求能被处理
第二个请求明确 Connection: close，因此第二段响应后连接结束
***************
failed
404+408
***************


✅2） Connection: Close（大小写/空格）
printf 'GET /upload//hello.txt HTTP/1.1\r\nHost: example.local\r\nConnection:  Close \r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,40p'
Connection Close -> keep_alive false
	•	Connection:  Close 
验证点：
	•	keep_alive == false
同一连接复测（应当只能看到第一段响应，第二段不会成功）
***************
failed
404
***************

printf 'GET /upload//hello.txt HTTP/1.1\r\nHost: example.local\r\nConnection:  Close \r\n\r\nGET /hello.txt HTTP/1.1\r\nHost: example.local\r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,120p'
只看到第一段响应
第二个请求不会得到第二段响应（因为连接已被服务器关闭，或 nc 会提示断开）
***************
failed
404
***************
=======================================================
update:
	curl指令：
	curl -v --http1.1 \
  -H "Connection:  Close " \
  "$BASE/upload/hello.txt" \
  "$BASE/hello.txt"
现在结果： 
	文件路径检查，2个都没问题，返回404/200 
	tcp 的connection： 2个分别close，然后走的新的路径而非复用
	reponse connection都是关闭
==========================================================


✅3）只有 keep-alive（应 keep_alive true）
printf 'GET /upload/hello.txt HTTP/1.1\r\nHost: example.local\r\nConnection: keep-alive\r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,40p'
***************
failed
404+408
***************
================================================================
update:
	curl指令：
	curl -v --http1.1 \
  -H "Connection: keep-alive" \
  "$BASE/upload/hello.txt" \
  "$BASE/upload/hello.txt"

现在结果： 
	文档是否存在，回复404/200 没有问题
	connection tcp底层都没有关闭 
	reponse 的keepalive也都保留
==============================================================

❓4）带未知 token
printf 'GET /upload/hello.txt HTTP/1.1\r\nHost: example.local\r\nConnection: keep-alive, upgrade, foo\r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,40p'
***************
failed
404+408
***************
============================================================
update：
curl指令：
curl -v --http1.1 \
  -H "Connection: keep-alive, upgrade, foo" \
  "$BASE/upload/hello.txt" \
  "$BASE/upload/hello.txt"

现在结果： 
		文件路径检查都没问题，回复404/200 都正确
		connection tcp地层都没有关闭，并且在同一个tcp连接上面
		reponse 那里，connection结果和request的一样Connection: keep-alive, upgrade, foo
==========================================================


✅5）token 前后空白与多个逗号
printf 'GET /upload//hello.txt HTTP/1.1\r\nHost: example.local\r\nConnection:   keep-alive  ,   close   \r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,40p'
***************
failed
404+408
***************
====================================
update： 
	curl指令：
	curl -v --http1.1 \
  -H "Connection:   keep-alive  ,   close   " \
  "$BASE/upload/hello.txt"

现在结果： 
	文件路径检查都没问题，回复404/200 
	connection tcp底层没问题
	reponse connect keepalive 
===========================================

6）行尾没有 CRLF 或出现裸 LF
printf 'GET / HTTP/1.1\nHost: example.local\n\n' | nc -v $HOST $PORT | sed -n '1,40p'
***************
ATTENT
408
从服务器视角，这个输入很可能被当成“请求还没结束”，parser 只把 \r\n 识别为换行与头结束标记（"\r\n\r\n"）。现在只发 \n\n，所以请求行可能还没“完整结束”（因为没有 \r\n）
header 区也没有出现 \r\n\r\n 作为终止符
于是连接进入 “READING_HEADERS” 状态，等待更多字节来凑齐 \r\n\r\n。但客户端（nc 管道）已经不再发送任何东西了，于是到了读超时点，就触发了 408。
当检测到出现裸 \n（LF）但前面不是 \r，并且你们不打算支持 LF-only 时，应立即判 400，而不是等超时给 408。
***************

3.6 Content-Length/Transfer-Encoding规则
✅1）POST 无长度信息 → 411
POST missing length info -> 411
printf 'POST /upload/misslen.txt HTTP/1.1\r\nHost: localhost\r\n\r\nhello' \
| nc -v $HOST $PORT | sed -n '1,40p'
//这里故意在 header 后放了 body 的“hello”，用来确认你们不会误读为 chunked 或者一直等。
***************
ATTENT
411 oui
mais 408
***************
==========================================
update: 
现在结果： 
		回复411
============================================


精确越界：
LIMIT=1000000
printf "POST /upload/toolarge2.txt HTTP/1.1\r\nHost: localhost\r\nContent-Length: $((LIMIT+1))\r\nConnection: close\r\n\r\n" \
| nc -v $HOST $PORT | sed -n '1,60p'
***************
failed
413 != 408
***************
========================
update： 
	curl指令：
	curl -v --http1.1 \
  -X POST \
  -H "Content-Length: 1000001" \
  --data-binary "" \
  "$BASE/upload/toolarge2.txt"

现在结果： 
	408 timeout 
===============================




✅printf 'POST /upload/chunk1.txt HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nhello\r\n6\r\n world\r\n0\r\n\r\n' \
| nc 127.0.0.1 $PORT | sed -n '1,40p'
test -f upload/chunk1.txt && echo "[OK] chunk1 exists" || echo "[FAIL] chunk1 missing"
预期：
	•	201
	•	文件落盘
	•	文件内容应为 hello world（cat upload/chunk1.txt验证）
检查文件落盘与内容
upload/chunk1.txt 路径要与 config 的 upload 目录一致。
test -f upload/chunk1.txt && echo "[OK] chunk1 exists" || echo "[FAIL] chunk1 missing"
cat upload/chunk1.txt | sed -n '1,5p'
期望：
文件存在
内容严格等于 hello world
***************
ATTENT
success 201 + hello world
mais 408
***************
=========================================
update:
现在状态： 
	回复201, 文件存在 
=========================================


8）chunk size 大小写十六进制
✅printf 'POST /upload/chunk_hex.txt HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\nA\r\n0123456789\r\n0\r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,80p'
期望：201，文件内容为 0123456789
***************
ATTENT
success 201 + 0123456789
mais 408
***************
========================================
update： 
现在结果： 
	回复201 
=======================================


✅10）chunked 缺少结尾 0\r\n\r\n
printf 'POST /upload/chunk_incomplete.txt HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nhello\r\n' \
| nc -v $HOST $PORT | sed -n '1,40p'
***************
ATTENT
success ici 408 ok
发现缺少终止块 0\r\n\r\n
超时 → 408
***************
正确结束的 chunked（应该不超时）:
printf 'POST /upload/chunk_ok.txt HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nhello\r\n0\r\n\r\n' \
| nc -v $HOST $PORT | sed -n '1,60p'
***************
ATTENT
success 201 
mais 408
***************
============================================
update： 
现在结果： 
第一个当chunk缺少结尾时，超时408 
第二个当chunk全部正确时，返回201 
============================================
